"use strict";
var fs = require('fs'), 
	express = require('express'),
	explorer = require("fs-helper"),
	view = require('./lib/View.js'),
	logger = require("custom-logger").new({
		info: { color: 'cyan', level: 0, event: 'info' },
		notice: { color: 'yellow', level: 1, event: 'notice' },
		warn: { color: 'yellow', level: 2, event: 'warning' },
		error: { color: 'red', level: 3, event: 'ERROR' }
	});

var app = express();

var that = {
    /*DEBUGMODE: {
        "error": 0,
        "warning": 1,
        "verbose": 2
    },
    debugIsOverThan: function(str) {
        return typeof(this.settings.DEBUG) == 'number' 
            ? this.settings.DEBUG >= this.DEBUGMODE[str]
            : this.DEBUGMODE[this.settings.DEBUG] >= this.DEBUGMODE[str];
    },
    log: function(level, message) {
        var debug = typeof(this.settings.DEBUG) == 'string' ? this.DEBUGMODE[this.settings.DEBUG] : this.settings.DEBUG;
        if (debug >= level) {
            var logMessage = '';
            switch(level) {
                case 0:
                    logMessage = '\u001b[31mERROR\u001b[0m: ';
                    break;
                case 1:
                    logMessage = '\u001b[33mWARNING\u001b[0m: ';
                    break;
            }
            console.log(logMessage.concat(message));
        }
    },*/
    controller: function(action, fn) {
        return {
            type: action == 'delete' ? 'del' : action,
            fn: fn
        };
    },
    settings: {
        DEBUG: 'verbose',
        ENV: 'dev',
        /* paths */
        controllersPath: './controllers/',
        modelsPath: './models/',
        viewsPath: './views/',
        routesFilePath: __dirname + "/../../config/"
    },
    attr: {
        /* Views cache */
        views: {},
		/* Controllers cache */
        controllers: {},
        /* instance of app ( from express() ) */
        app: null
    },
    /**
     * Load all your models, views and controllers
     * @param {Object} settings
     * @param {Function} callback
    **/
    load: function(settings, callback) {
        for(var i in settings) {
            if (this.settings[i] != undefined) {
				logger.warn('mvc.settings.' + i + ' is overwritten.');
            }
            this.settings[i] = settings[i];
        }
        // load models
        /*this.loadModels(settings, function(models) {
            app.models = models;
        });*/
        
        this.loadViews(function() {// load views
            that._loadControllers(callback);// load controllers
        });
        
        
    },
    loadModels: function(settings, callback) {
        var modelsPath = this.settings.modelsPath,
        modelsContainer = this.models,
        modelName=null,
        model=null;
        
        fs.readdir(modelsPath, function(err, files) {
            if (err) { that.loader.errorMessage(err); throw err; }
            for(var name in files) {
                if (/^.*~$/.exec(files[name])) { continue; }
                modelName = files[name].split('.')[0];
                model = require(modelsPath + files[name]);
                console.log('MODEL: ' + modelName + ' \u001b[32mloaded\u001b[0m');
                modelsContainer[modelName] = model;
            }
            if (callback) { callback(modelsContainer); }
        });
    },
    loadViews: function(callback) {
		
        explorerSync(this.settings.viewsPath, function(pathname, stat) {
			var index = /(\.[^.]+)$/.exec(pathname).index,
				pathFileWithoutExt = pathname.substr(0, index),
				viewPath = pathFileWithoutExt.substr(that.settings.viewsPath.length-1, pathFileWithoutExt.length);
			if (this.settings.ENV == 'dev') { // dev modes
				if(that.attr.views[viewPath] != null) { logger.warn('the path ' + pathFileWithoutExt + ' already exists. ' + that.attr.views[viewPath]); }
				logger.info('\u001b[32mLOAD VIEW PATH\u001b[0m ' + pathname + ' \u001b[32minto\u001b[0m ' + viewPath)
				that.attr.views[viewPath] = pathname;
			} else if (this.settings.ENV == 'prod') { // prod mode
				logger.info('\u001b[32mLOAD VIEW\u001b[0m: ' + pathFileWithoutExt);
				if(that.attr.views[viewPath] != null) {  logger.warn('the path ' + pathFileWithoutExt + ' already exists. ' + that.attr.views[viewPath]); }
				that.attr.views[viewPath] = view(pathname);
			}
		});
        callback();
    },
    
    },
    setRoute: function(controller, method, action, url) {
        action = action || 'get';
        // Define common variables
        if (!controller || typeof(controller) != 'string') {
            logger.info('The controller is not defined or this is not a string');
        }
        var controllerName = controller.concat('Controller');
        var path = this.settings.controllersPath.concat(controller, 'Controller.js');
        var expressAction = action.toLowerCase() == 'delete' ? 'del' : action.toLowerCase();
        
        
        if (this.settings.ENV == 'dev') { // dev modes
            logger.info('\u001b[32mSET ROUTE\u001b[0m: ' + '[' + action.toUpperCase() + '] ' + url);
            // SET ROUTE WITH FUNCTION HANDLER TO REQUIRE CONTROLLER ON REQUEST
			var that = this;
            this.attr.app[expressAction](url, (function(path, controllerName, method, loader) {
                return function(req, res, next) {
                    logger.info('\u001b[32mLOAD CONTROLLER\u001b[0m: ' + path);
                    // REQUIRE CONTROLLER
                    var controller = require(path)[controllerName];
                    controller.view = function(str) {
						return view(loader.attr.views[str]);
					};
                    if (controller[method]) {
                        // CALL FUNCTION
                        controller[method](req, res, next);
                    } else {
                        logger.error('The method \u001b[32m' + controllerName + '\u001b[0m.\u001b[32m' + method + '\u001b[0m required for \u001b[32m[' + action.toUpperCase() + '] ' + url + '\u001b[0m is not found !');
                    }
                }
            })(path, controllerName, method, this));
            
        } else if (this.settings.ENV == 'prod') { // prod mode
            var that = this;
			logger.info('\u001b[32mLOAD CONTROLLER\u001b[0m: ' + controllerName + '.' + method);
            // REQUIRE CONTROLLER
            if (this.attr.controllers[controllerName] == undefined) {
                controller = require(path)[controllerName];
                controller.view = (function(str) {
                    return that.attr.views[str];
                }).bind(controller);
                this.attr.controllers[controllerName] = controller;
            }
            // IF CONTROLLER HAS METHOD
            if (this.attr.controllers[controllerName][method]) {
                // GET CONTROLLER METHOD
                var controllerMethod = this.attr.controllers[controllerName][method].bind(this.attr.controllers[controllerName]);
                // DEFINE ROUTE
                this.attr.app[expressAction](url, controllerMethod);
            } else {
                logger.error('The method \u001b[32m' + controllerName + '\u001b[0m.\u001b[32m' + method + '\u001b[0m required for \u001b[32m[' + action.toUpperCase() + '] ' + url + '\u001b[0m is not found !');
            }
        }
    },
    _loadControllers: function(callback) {
        var routes = this.loadRoutesFromFile(),
        controller=null,
        controllerName=null,
        method=null,
        action=null;
        for(var url in routes) {
            if (routes[url].controller) {
                controller = routes[url].controller;
                method = routes[url].method;
                action = routes[url].action;
                this.setRoute(controller, method, action, url);
            } else if (routes[url] instanceof Array && routes[url].length > 0) {
                if (typeof(routes[url][0]) == 'string') {
                    controller = routes[url][0];
                    if (typeof(routes[url][1]) == 'string') {
                        method = routes[url][1];
                        action = routes[url][2];
                        this.setRoute(controller, method, action, url);
                    } else {
                        for(var i=1;i<routes[url].length;i++) {
                            method = routes[url][i].method;
                            action = routes[url][i].action;
                            this.setRoute(controller, method, action, url);
                        }
                    }
                } else {
                    for(var i=0;i<routes[url].length;i++) {
                        if (routes[url][i] instanceof Array) {
                            
                            controller = routes[url][i][0];
                            method = routes[url][i][1];
                            action = routes[url][i][2];
                        } else if (routes[url][i] instanceof Object) {
                            controller = routes[url][i].controller;
                            method = routes[url][i].method;
                            action = routes[url][i].action;
                        }
                        this.setRoute(controller, method, action, url);
                    }
                }
            }
        }
        if (callback) { callback(); }
    },
    loadRoutesFromFile: function() {
        var routesPath = this.settings.routesFilePath + 'routes.json';
		console.log(routesPath);
        if (!fs.existsSync(routesPath)) {
            fs.writeSync(routesPath, '{}');
        }
        var file_content = fs.readFileSync(routesPath);
        if (file_content.length > 0) {
            var json_content = JSON.parse(file_content);
            return json_content;
        }
        return null;
    },
    errorMessage: function(err) {
        var message = '';
        switch(err.errno) {
            case 34:
                message = 'invalid path'; break;
            default:
                message = 'UNHANDLED';
        }
        console.log(err);
        logger.error(message);
    }
};

module.exports = function(app) {
    if (app) {
        that.attr.app = app;
    }
    return that;
};
